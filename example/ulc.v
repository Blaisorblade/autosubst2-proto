(* This code was automatically generated by Autosubst 2.0 Beta.

The following inductive types were generated:
tm : Type

The following variable constructors were generated:
var_tm : Type

Autosubst 2 uses vectors of substitutions. The types of the generated substiutions are listed below:
subst_of subst_of_tm := index -> tm

Autosubst 2 furthermore generated the following instantiation operations:
subst_tm : subst_of subst_of_tm -> tm -> tm,
also accessible as s.[sigma]

See the generated dot-graph for further details.

Automation has been extended to include the generated definitions. The tactic asimpl simplifies goals containing substiution expressions, autosubst corresponds to now asimpl.

If Autosubst 2 does not behave as expected, we are grateful for a short mail to autosubst@ps.uni-saarland.de.
Thank you!
*)

Require Export Autosubst2.
Set Implicit Arguments.
Require Import Lists.List.
Import ListNotations.
Set Typeclasses Filtered Unification.

Inductive tm  : Type :=
  | var_tm : index -> tm
  | app : tm -> tm -> tm
  | lam : tm -> tm.

Definition congr_app {s0 s1 t0 t1: tm} (E0: s0 = t0) (E1: s1 = t1) : app s0 s1 = app t0 t1 :=
  apc (ap app E0) (E1).

Definition congr_lam {s0 t0: tm} (E0: s0 = t0) : lam s0 = lam t0 :=
  ap lam E0.

Definition subst_of_tm  : list Type :=
  [tm: Type].

Definition toVarRen_tm (xi: ren_of subst_of_tm) : _ :=
  let xi := xi in xi.



Definition upren_tm_tm (xi: ren_of subst_of_tm) : ren_of subst_of_tm :=
  let xi_tm := xi in up_ren xi_tm.

Fixpoint ren_tm (xi: ren_of subst_of_tm) (s: tm) : tm :=
  match s with
  | var_tm x => var_tm ((toVarRen_tm xi) x)
  | app s0 s1 => app ((ren_tm xi s0)) ((ren_tm xi s1))
  | lam s0 => lam ((ren_tm (upren_tm_tm xi) s0))
  end.

Definition toVar_tm (sigma: subst_of subst_of_tm) : _ :=
  let sigma := sigma in sigma.

Definition eq_toVar_tm {sigma tau: subst_of subst_of_tm} (E: eq_of_subst sigma tau) (n: index) : toVar_tm sigma n = toVar_tm tau n.
  rename sigma into sigma_tm. rename tau into tau_tm. rename E into E_tm.
  exact (E_tm n).
Defined.

Definition compren_tm (sigma: subst_of subst_of_tm) (xi: ren_of subst_of_tm) : subst_of subst_of_tm :=
  match sigma with
  | sigma_tm => fun x => ren_tm xi (sigma_tm x)
  end.

Definition up_tm_tm (sigma: subst_of subst_of_tm) : subst_of subst_of_tm :=
  match compren_tm sigma S with
  | sigma_tm => scons (var_tm 0) sigma_tm
  end.





Fixpoint subst_tm (sigma: subst_of subst_of_tm) (s: tm) : tm :=
  match s with
  | var_tm x =>  ((toVar_tm sigma) x)
  | app s0 s1 => app ((subst_tm sigma s0)) ((subst_tm sigma s1))
  | lam s0 => lam ((subst_tm (up_tm_tm sigma) s0))
  end.

Definition comp_tm (sigma tau: subst_of subst_of_tm) : subst_of subst_of_tm :=
  match sigma with
  | sigma_tm => fun x => subst_tm tau (sigma_tm x)
  end.

Definition substMixin_tm  : substMixin tm :=
  {|subst_of_substType := subst_of_tm;inst_of_substType := subst_tm|}.

Canonical Structure substType_tm  : substType :=
  Eval hnf in @Pack tm substMixin_tm tm.

Definition upId_tm_tm (sigma_tm: index -> tm) (E_tm: sigma_tm == var_tm) : @eq_of_subst subst_of_tm (up_tm_tm sigma_tm) var_tm :=
  fun n => match n return (match up_tm_tm sigma_tm with
  | tau_tm => tau_tm n = var_tm  n
  end) with
  | 0 => eq_refl
  | S n => ap (ren_tm S) (E_tm n)
  end.

Fixpoint id_tm (sigma_tm: index -> tm) (E_tm: sigma_tm == var_tm) (s: tm) : subst_tm sigma_tm s = s :=
  match s with
  | var_tm n => E_tm n
  | app s0 s1 => apc (ap app (id_tm _ E_tm s0)) ((id_tm _ E_tm s1))
  | lam s0 => ap lam (match upId_tm_tm _ E_tm with
      | E_tm => id_tm _ E_tm s0
      end)
  end.

Definition toSubst_tm (xi: ren_of subst_of_tm) : subst_of subst_of_tm :=
  match xi with
  | xi_tm => fun x => var_tm (xi_tm x)
  end.

Fixpoint compTrans_ren_ren_tm (xi_tm zeta_tm theta_tm: ren) (E_tm: funcomp (xi_tm) (zeta_tm) == theta_tm) (s: tm)
           : ren_tm zeta_tm (ren_tm xi_tm s) = ren_tm theta_tm s :=
  match s with
  | var_tm n => ap var_tm (E_tm n)
  | app s0 s1 => apc (ap app (compTrans_ren_ren_tm xi_tm zeta_tm theta_tm E_tm s0)) ((compTrans_ren_ren_tm xi_tm zeta_tm theta_tm E_tm s1))
  | lam s0 => ap lam (compTrans_ren_ren_tm (up_ren xi_tm) (up_ren zeta_tm) (up_ren theta_tm) (up_ren_ren xi_tm zeta_tm theta_tm E_tm) s0)
  end.

Definition compE_ren_ren_tm (xi_tm zeta_tm: ren) (s: tm) : ren_tm zeta_tm (ren_tm xi_tm s) = ren_tm (funcomp xi_tm zeta_tm) s :=
  compTrans_ren_ren_tm xi_tm zeta_tm (funcomp xi_tm zeta_tm) (fun _ => eq_refl) s.

Definition up_ren_subst_tm_tm (xi_tm: ren) (theta_tm tau_tm: index -> tm) (E_tm: (fun x =>  theta_tm (xi_tm x)) == tau_tm)
  : @eq_of_subst subst_of_tm (comp_tm (toSubst_tm (upren_tm_tm xi_tm)) (up_tm_tm theta_tm)) (up_tm_tm tau_tm) :=
  fun n => match n return match comp_tm (toSubst_tm (upren_tm_tm xi_tm)) (up_tm_tm theta_tm), up_tm_tm tau_tm with
  | xi_tm, tau_tm => xi_tm n = tau_tm n
  end with
  | 0 => eq_refl
  | S n => ap (ren_tm S) (E_tm n)
  end.

Fixpoint compTrans_ren_subst_tm (xi_tm: ren) (tau_tm theta_tm: index -> tm) (E_tm: (fun x =>  tau_tm (xi_tm x)) == theta_tm) (s: tm)
           : subst_tm tau_tm (ren_tm xi_tm s) = subst_tm theta_tm s :=
  match s with
  | var_tm n =>  (E_tm n)
  | app s0 s1 => apc (ap app (compTrans_ren_subst_tm xi_tm _ _ E_tm s0)) ((compTrans_ren_subst_tm xi_tm _ _ E_tm s1))
  | lam s0 => ap lam (match up_ren_subst_tm_tm xi_tm tau_tm theta_tm E_tm with
      | E_tm => compTrans_ren_subst_tm (up_ren xi_tm) _ _ E_tm s0
      end)
  end.

Definition compE_ren_subst_tm (xi_tm: ren) (tau_tm: index -> tm) (s: tm)
  : subst_tm tau_tm (ren_tm xi_tm s) = subst_tm (funcomp xi_tm tau_tm) s :=
  compTrans_ren_subst_tm xi_tm tau_tm (funcomp xi_tm tau_tm) (fun _ => eq_refl) s.

Definition up_subst_ren_tm_tm (sigma_tm: index -> tm)
  (rho_tm: ren)
  (tau_tm: index -> tm)
  (E_tm: (fun x =>  ren_tm rho_tm (sigma_tm x)) == tau_tm)
  : @eq_of_subst subst_of_tm (compren_tm (up_tm_tm sigma_tm) (upren_tm_tm rho_tm)) (up_tm_tm tau_tm) :=
  fun n => match n return match compren_tm (up_tm_tm sigma_tm) (upren_tm_tm rho_tm), up_tm_tm tau_tm with
  | sigma_tm, tau_tm => sigma_tm n = tau_tm n
  end with
  | 0 => eq_refl
  | S n =>
      eq_trans (compE_ren_ren_tm S (up_ren rho_tm) (sigma_tm n)) (eq_trans (eq_sym (compE_ren_ren_tm rho_tm S (sigma_tm n))) (ap (ren_tm S) (E_tm n)))
  end.

Fixpoint compTrans_subst_ren_tm (sigma_tm: index -> tm)
           (zeta_tm: ren)
           (theta_tm: index -> tm)
           (E_tm: (fun x =>  ren_tm zeta_tm (sigma_tm x)) == theta_tm)
           (s: tm) : ren_tm zeta_tm (subst_tm sigma_tm s) = subst_tm theta_tm s :=
  match s with
  | var_tm n =>  (E_tm n)
  | app s0 s1 => apc (ap app (compTrans_subst_ren_tm _ zeta_tm _ E_tm s0)) ((compTrans_subst_ren_tm _ zeta_tm _ E_tm s1))
  | lam s0 => ap lam (match up_subst_ren_tm_tm sigma_tm zeta_tm theta_tm E_tm with
      | E_tm => compTrans_subst_ren_tm _ (up_ren zeta_tm) _ E_tm s0
      end)
  end.

Definition compE_subst_ren_tm (sigma_tm: index -> tm) (zeta_tm: ren) (s: tm)
  : ren_tm zeta_tm (subst_tm sigma_tm s) = subst_tm (fun n => ren_tm (zeta_tm) (sigma_tm n)) s :=
  compTrans_subst_ren_tm sigma_tm zeta_tm (fun n => ren_tm (zeta_tm) (sigma_tm n)) (fun _ => eq_refl) s.

Definition up_subst_subst_tm_tm (sigma_tm theta_tm tau_tm: index -> tm) (E_tm: (fun x =>  subst_tm theta_tm (sigma_tm x)) == tau_tm)
  : @eq_of_subst subst_of_tm (comp_tm (up_tm_tm sigma_tm) (up_tm_tm theta_tm)) (up_tm_tm tau_tm) :=
  fun n => match n return match comp_tm (up_tm_tm sigma_tm) (up_tm_tm theta_tm), up_tm_tm tau_tm with
  | sigma_tm, tau_tm => sigma_tm n = tau_tm n
  end with
  | 0 => eq_refl
  | S n =>
      eq_trans (compE_ren_subst_tm S _ (sigma_tm n)) (eq_trans (eq_sym (compE_subst_ren_tm theta_tm S (sigma_tm n))) (ap (ren_tm S) (E_tm n)))
  end.

Fixpoint compTrans_subst_subst_tm (sigma_tm tau_tm theta_tm: index -> tm)
           (E_tm: (fun x =>  subst_tm tau_tm (sigma_tm x)) == theta_tm)
           (s: tm) : subst_tm tau_tm (subst_tm sigma_tm s) = subst_tm theta_tm s :=
  match s with
  | var_tm n =>  (E_tm n)
  | app s0 s1 => apc (ap app (compTrans_subst_subst_tm _ _ _ E_tm s0)) ((compTrans_subst_subst_tm _ _ _ E_tm s1))
  | lam s0 => ap lam (match up_subst_subst_tm_tm sigma_tm tau_tm theta_tm E_tm with
      | E_tm => compTrans_subst_subst_tm _ _ _ E_tm s0
      end)
  end.

Definition compE_subst_subst_tm (sigma_tm tau_tm: index -> tm) (s: tm)
  : subst_tm tau_tm (subst_tm sigma_tm s) = subst_tm (fun n => subst_tm (tau_tm) (sigma_tm n)) s :=
  compTrans_subst_subst_tm sigma_tm tau_tm (fun n => subst_tm (tau_tm) (sigma_tm n)) (fun _ => eq_refl) s.

Definition eq_up_tm_tm {sigma tau: subst_of subst_of_tm} (E: eq_of_subst sigma tau) : eq_of_subst (up_tm_tm sigma) (up_tm_tm tau).
  rename sigma into sigma_tm. rename tau into tau_tm. rename E into E_tm.
  exact (fun i: index => match i return (var_tm 0 .: sigma_tm >>> ren_tm S) i = (var_tm 0 .: tau_tm >>> ren_tm S) i with 0 => eq_refl
                                                                                                                     | S j => ap _ (E_tm j) end).
Defined.

Fixpoint subst_eq_tm {sigma tau: subst_of subst_of_tm} (E: eq_of_subst sigma tau) (s: tm) : subst_tm sigma s = subst_tm tau s :=
  match s with
  | var_tm n => eq_toVar_tm E n
  | app s0 s1 => congr_app (subst_eq_tm E s0) (subst_eq_tm E s1)
  | lam s0 => congr_lam (subst_eq_tm (eq_up_tm_tm E) s0)
  end.

Class AsimplInst_tm (s: tm) (sigma: subst_of subst_of_tm) (t: tm) := asimplInstEqn_tm : (subst_tm sigma) s = t .
Hint Mode AsimplInst_tm + + - : typeclass_instance.

Class AsimplSubst_tm (sigma tau: subst_of subst_of_tm) := asimplSubstEqn_tm : match sigma, tau with
| sigma_tm, tau_tm => (forall x, sigma_tm x = tau_tm x)
end .
Hint Mode AsimplSubst_tm + - : typeclass_instance.

Class AsimplComp_tm (sigma tau theta: subst_of subst_of_tm) := asimplCompEqn_tm : match comp_tm sigma tau, theta with
| sigma_tau_tm, theta_tm => (forall x, sigma_tau_tm x = theta_tm x)
end .
Hint Mode AsimplComp_tm + + - : typeclass_instance.



Instance AsimplToVar_tm (sigma_tm: index -> tm) : AsimplGen (toVar_tm sigma_tm) sigma_tm.
Proof. intros x. reflexivity. Qed.

Instance AsimplAsimplInst_tm (s t: tm)
(sigma sigma': subst_of subst_of_tm)
(E_sigma: AsimplSubst_tm sigma sigma')
(E: AsimplInst_tm s sigma' t) : Asimpl (subst_tm sigma s) t.
Proof. rewrite <- E. apply subst_eq_tm. assumption. Qed.

Instance AsimplInstRefl_tm (s: tm) (sigma: subst_of subst_of_tm) : AsimplInst_tm s sigma (s.[ sigma ]) |100.
Proof. reflexivity. Qed.

Instance AsimplInstVar_tm (x y: index)
(sigma: subst_of subst_of_tm)
(sigma': index -> tm)
(s: tm)
(E: AsimplIndex x y)
(E': AsimplGen (toVar_tm sigma) sigma')
(E'': AsimplVarInst y sigma' s) : AsimplInst_tm (var_tm x) sigma s.
Proof. rewrite E. rewrite <- E''. apply E'.  Qed.

Instance asimplInst_app (s0 s1 s0' s1': _)
(sigma theta_0 theta_1: subst_of subst_of_tm)
(E_0': AsimplSubst_tm (sigma) theta_0)
(E_1': AsimplSubst_tm (sigma) theta_1)
(E_0: AsimplInst_tm s0 theta_0 s0')
(E_1: AsimplInst_tm s1 theta_1 s1') : AsimplInst_tm (app s0 s1) sigma (app s0' s1').
Admitted.
Instance asimplInst_lam (s0 s0': _)
(sigma theta_0: subst_of subst_of_tm)
(E_0': AsimplSubst_tm ((up_tm_tm sigma)) theta_0)
(E_0: AsimplInst_tm s0 theta_0 s0') : AsimplInst_tm (lam s0) sigma (lam s0').
Admitted.

Instance AsimplId_tm (s: tm) : AsimplInst_tm s var_tm s.
Proof. apply id_tm; reflexivity. Qed.

Instance AsimplInstInst_tm (s t: tm)
(sigma sigma' tau sigma_tau: subst_of subst_of_tm)
(E1: AsimplSubst_tm sigma sigma')
(E2: AsimplComp_tm sigma' tau sigma_tau)
(E3: AsimplInst_tm s sigma_tau t) : AsimplInst_tm (subst_tm sigma s) tau t.
Admitted.

Instance AsimplSubstRefl_tm (sigma: subst_of subst_of_tm) : AsimplSubst_tm sigma sigma | 100.
Admitted.

Instance AsimplSubstComp_tm (sigma sigma' tau tau' theta: subst_of subst_of_tm)
(E_sigma: AsimplSubst_tm sigma sigma')
(E_tau: AsimplSubst_tm tau tau')
(E: AsimplComp_tm sigma' tau' theta) : AsimplSubst_tm (comp_tm sigma tau) theta |90.
Admitted.

Instance AsimplSubstCongr_tm (sigma_tm tau_tm: index -> tm) (E_tm: AsimplGen sigma_tm tau_tm) : AsimplSubst_tm sigma_tm tau_tm |95.
Proof. repeat split; assumption. Qed.

Instance AsimplCompRefl_tm (sigma tau: subst_of subst_of_tm) : AsimplComp_tm sigma tau (comp_tm sigma tau) | 100.
Admitted.

Instance AsimplCompIdL_tm (sigma: subst_of subst_of_tm)
(tau: index -> tm)
(E: AsimplGen (toVar_tm sigma) tau) : AsimplComp var_tm (subst_tm sigma) tau.
Admitted.

Instance AsimplCompIdR_tm (sigma: index -> tm) : AsimplComp sigma (subst_tm var_tm) sigma.
Proof. intros x. apply id_tm; reflexivity. Qed.

Instance AsimplCompAsso_tm (sigma tau theta tau_theta sigma_tau_theta: subst_of subst_of_tm)
(E: AsimplComp_tm tau theta tau_theta)
(E': AsimplComp_tm sigma tau_theta sigma_tau_theta) : AsimplComp_tm (comp_tm sigma tau) theta sigma_tau_theta.
Admitted.

Instance AsimplCompCongr_tm (sigma_tm theta_tm: index -> tm)
(tau_tm tau: subst_of subst_of_tm)
(E_tm: AsimplSubst_tm (tau) tau_tm)
(E_tm': AsimplComp sigma_tm (subst_tm tau_tm) theta_tm) : AsimplComp_tm sigma_tm tau theta_tm.
Admitted.

Instance AsimplCompCongr'_tm (sigma_tm theta_tm: index -> tm)
(tau_tm tau: subst_of subst_of_tm)
(E_tm: AsimplSubst_tm (tau) tau_tm)
(E_tm': AsimplComp sigma_tm (subst_tm tau_tm) theta_tm) : AsimplComp (subst_tm sigma_tm) (subst_tm tau) (subst_tm theta_tm).
Admitted.

Instance AsimplRefl_tm (s: tm) : Asimpl s s | 100.
Proof. reflexivity. Qed.

Instance AsimplGenComp_tm (sigma sigma': index -> tm)
(tau tau': subst_of subst_of_tm)
(theta: index -> tm)
(E: AsimplGen sigma sigma')
(E': AsimplSubst_tm tau tau')
(E'': AsimplComp sigma' (subst_tm tau') theta) : AsimplGen (sigma >>> (subst_tm tau) ) theta.
Proof. intros x. rewrite <- E''. simpl. rewrite E. now apply subst_eq_tm . Qed.

Instance AsimplSubstUp_tm_tm (sigma_tm tau_tm: index -> tm)
(E_tm: AsimplGen (var_tm 0 .: sigma_tm >>> (subst_tm ((S >>> var_tm)))) tau_tm) : AsimplSubst_tm (up_tm_tm sigma_tm) tau_tm.
Admitted.

Typeclasses Opaque toVar_tm.

