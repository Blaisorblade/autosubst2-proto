(* This code was automatically generated by Autosubst 2.0 Beta.

The following inductive types were generated:
ty : Type
tm : Type
vl : Type

The following variable constructors were generated:
var_vl : Type

Autosubst 2 uses vectors of substitutions. The types of the generated substiutions are listed below:
subst_of subst_of_ty := index -> vl
subst_of subst_of_tm := index -> vl
subst_of subst_of_vl := index -> vl

Autosubst 2 furthermore generated the following instantiation operations:
subst_ty : subst_of subst_of_ty -> ty -> ty,
also accessible as s.[sigma]
subst_tm : subst_of subst_of_tm -> tm -> tm,
also accessible as s.[sigma]
subst_vl : subst_of subst_of_vl -> vl -> vl,
also accessible as s.[sigma]

See the generated dot-graph for further details.

Automation has been extended to include the generated definitions. The tactic asimpl simplifies goals containing substiution expressions, autosubst corresponds to now asimpl.

If Autosubst 2 does not behave as expected, we are grateful for a short mail to autosubst@ps.uni-saarland.de.
Thank you!
*)

Require Export Autosubst2.
Set Implicit Arguments.
Require Import Lists.List.
Import ListNotations.
Set Typeclasses Filtered Unification.

Inductive ty  : Type :=
  
  | TNat :  ty
  | TAll : ty -> ty -> ty
  | TSel : vl -> ty
  | TSelA : vl -> ty -> ty
  | TBind : ty -> ty
  | TSBind : ty -> ty -> ty
 with tm  : Type :=
  
  | tapp : tm -> tm -> tm
  | tlet : tm -> tm -> tm
  | tproj : tm -> tm
  | vt : vl -> tm
 with vl  : Type :=
  | var_vl : index -> vl
  | vabs : tm -> vl
  | vrec : tm -> vl
  | vpack : ty -> tm -> vl.

Definition congr_TNat  : TNat  = TNat  :=
  eq_refl.

Definition congr_TAll {s0 s1 t0 t1: ty} (E0: s0 = t0) (E1: s1 = t1) : TAll s0 s1 = TAll t0 t1 :=
  apc (ap TAll E0) (E1).

Definition congr_TSel {s0 t0: vl} (E0: s0 = t0) : TSel s0 = TSel t0 :=
  ap TSel E0.

Definition congr_TSelA {s0: vl} {s1: ty} {t0: vl} {t1: ty} (E0: s0 = t0) (E1: s1 = t1) : TSelA s0 s1 = TSelA t0 t1 :=
  apc (ap TSelA E0) (E1).

Definition congr_TBind {s0 t0: ty} (E0: s0 = t0) : TBind s0 = TBind t0 :=
  ap TBind E0.

Definition congr_TSBind {s0 s1 t0 t1: ty} (E0: s0 = t0) (E1: s1 = t1) : TSBind s0 s1 = TSBind t0 t1 :=
  apc (ap TSBind E0) (E1).

Definition congr_tapp {s0 s1 t0 t1: tm} (E0: s0 = t0) (E1: s1 = t1) : tapp s0 s1 = tapp t0 t1 :=
  apc (ap tapp E0) (E1).

Definition congr_tlet {s0 s1 t0 t1: tm} (E0: s0 = t0) (E1: s1 = t1) : tlet s0 s1 = tlet t0 t1 :=
  apc (ap tlet E0) (E1).

Definition congr_tproj {s0 t0: tm} (E0: s0 = t0) : tproj s0 = tproj t0 :=
  ap tproj E0.

Definition congr_vt {s0 t0: vl} (E0: s0 = t0) : vt s0 = vt t0 :=
  ap vt E0.

Definition congr_vabs {s0 t0: tm} (E0: s0 = t0) : vabs s0 = vabs t0 :=
  ap vabs E0.

Definition congr_vrec {s0 t0: tm} (E0: s0 = t0) : vrec s0 = vrec t0 :=
  ap vrec E0.

Definition congr_vpack {s0: ty} {s1: tm} {t0: ty} {t1: tm} (E0: s0 = t0) (E1: s1 = t1) : vpack s0 s1 = vpack t0 t1 :=
  apc (ap vpack E0) (E1).

Definition subst_of_ty  : list Type :=
  [vl: Type].

Definition subst_of_tm  : list Type :=
  [vl: Type].

Definition subst_of_vl  : list Type :=
  [vl: Type].

Definition toVarRen_ty (xi: ren_of subst_of_ty) : _ :=
  let _ := xi in xi.

Definition toVarRen_tm (xi: ren_of subst_of_tm) : _ :=
  let _ := xi in xi.

Definition toVarRen_vl (xi: ren_of subst_of_vl) : _ :=
  let xi := xi in xi.

Definition castren_ty_vl (xi: ren_of subst_of_ty) : ren_of subst_of_vl :=
  let xi_vl := xi in xi_vl.

Definition castren_tm_vl (xi: ren_of subst_of_tm) : ren_of subst_of_vl :=
  let xi_vl := xi in xi_vl.

Definition castren_vl_tm (xi: ren_of subst_of_vl) : ren_of subst_of_tm :=
  let xi_vl := xi in xi_vl.

Definition castren_vl_ty (xi: ren_of subst_of_vl) : ren_of subst_of_ty :=
  let xi_vl := xi in xi_vl.

Definition upren_ty_vl (xi: ren_of subst_of_ty) : ren_of subst_of_ty :=
  let xi_vl := xi in up_ren xi_vl.

Definition upren_tm_vl (xi: ren_of subst_of_tm) : ren_of subst_of_tm :=
  let xi_vl := xi in up_ren xi_vl.

Definition upren_vl_vl (xi: ren_of subst_of_vl) : ren_of subst_of_vl :=
  let xi_vl := xi in up_ren xi_vl.

Fixpoint ren_ty (xi: ren_of subst_of_ty) (s: ty) : ty :=
  match s with
  
  | TNat  => TNat 
  | TAll s0 s1 => TAll ((ren_ty xi s0)) ((ren_ty (upren_ty_vl xi) s1))
  | TSel s0 => TSel ((ren_vl (castren_ty_vl xi) s0))
  | TSelA s0 s1 => TSelA ((ren_vl (castren_ty_vl xi) s0)) ((ren_ty xi s1))
  | TBind s0 => TBind ((ren_ty (upren_ty_vl xi) s0))
  | TSBind s0 s1 => TSBind ((ren_ty xi s0)) ((ren_ty (upren_ty_vl xi) s1))
  end
 with ren_tm (xi: ren_of subst_of_tm) (s: tm) : tm :=
  match s with
  
  | tapp s0 s1 => tapp ((ren_tm xi s0)) ((ren_tm xi s1))
  | tlet s0 s1 => tlet ((ren_tm xi s0)) ((ren_tm (upren_tm_vl xi) s1))
  | tproj s0 => tproj ((ren_tm xi s0))
  | vt s0 => vt ((ren_vl (castren_tm_vl xi) s0))
  end
 with ren_vl (xi: ren_of subst_of_vl) (s: vl) : vl :=
  match s with
  | var_vl x => var_vl ((toVarRen_vl xi) x)
  | vabs s0 => vabs ((ren_tm (upren_vl_vl (castren_vl_tm xi)) s0))
  | vrec s0 => vrec ((ren_tm (upren_vl_vl (castren_vl_tm xi)) s0))
  | vpack s0 s1 => vpack ((ren_ty (castren_vl_ty xi) s0)) ((ren_tm (castren_vl_tm xi) s1))
  end.

Definition toVar_ty (sigma: subst_of subst_of_ty) : _ :=
  let _ := sigma in sigma.

Definition toVar_tm (sigma: subst_of subst_of_tm) : _ :=
  let _ := sigma in sigma.

Definition toVar_vl (sigma: subst_of subst_of_vl) : _ :=
  let sigma := sigma in sigma.





Definition eq_toVar_vl {sigma tau: subst_of subst_of_vl} (E: eq_of_subst sigma tau) (n: index) : toVar_vl sigma n = toVar_vl tau n.
  rename sigma into sigma_vl. rename tau into tau_vl. rename E into E_vl.
  exact (E_vl n).
Defined.

Definition compren_ty (sigma: subst_of subst_of_ty) (xi: ren_of subst_of_ty) : subst_of subst_of_ty :=
  match sigma with
  | sigma_vl => fun x => ren_vl (castren_ty_vl xi) (sigma_vl x)
  end.

Definition compren_tm (sigma: subst_of subst_of_tm) (xi: ren_of subst_of_tm) : subst_of subst_of_tm :=
  match sigma with
  | sigma_vl => fun x => ren_vl (castren_tm_vl xi) (sigma_vl x)
  end.

Definition compren_vl (sigma: subst_of subst_of_vl) (xi: ren_of subst_of_vl) : subst_of subst_of_vl :=
  match sigma with
  | sigma_vl => fun x => ren_vl xi (sigma_vl x)
  end.

Definition up_ty_vl (sigma: subst_of subst_of_ty) : subst_of subst_of_ty :=
  match compren_ty sigma S with
  | sigma_vl => scons (var_vl 0) sigma_vl
  end.

Definition up_tm_vl (sigma: subst_of subst_of_tm) : subst_of subst_of_tm :=
  match compren_tm sigma S with
  | sigma_vl => scons (var_vl 0) sigma_vl
  end.

Definition up_vl_vl (sigma: subst_of subst_of_vl) : subst_of subst_of_vl :=
  match compren_vl sigma S with
  | sigma_vl => scons (var_vl 0) sigma_vl
  end.

Definition cast_ty_vl (sigma: subst_of subst_of_ty) : subst_of subst_of_vl :=
  let sigma_vl := sigma in sigma_vl.

Definition cast_tm_vl (sigma: subst_of subst_of_tm) : subst_of subst_of_vl :=
  let sigma_vl := sigma in sigma_vl.

Definition cast_vl_tm (sigma: subst_of subst_of_vl) : subst_of subst_of_tm :=
  let sigma_vl := sigma in sigma_vl.

Definition cast_vl_ty (sigma: subst_of subst_of_vl) : subst_of subst_of_ty :=
  let sigma_vl := sigma in sigma_vl.

Definition eq_cast_ty_vl {sigma tau: subst_of subst_of_ty} (E: eq_of_subst sigma tau) : eq_of_subst (cast_ty_vl sigma) (cast_ty_vl tau).
  rename sigma into sigma_vl. rename tau into tau_vl. rename E into E_vl.
  exact (E_vl).
Defined.

Definition eq_cast_tm_vl {sigma tau: subst_of subst_of_tm} (E: eq_of_subst sigma tau) : eq_of_subst (cast_tm_vl sigma) (cast_tm_vl tau).
  rename sigma into sigma_vl. rename tau into tau_vl. rename E into E_vl.
  exact (E_vl).
Defined.

Definition eq_cast_vl_tm {sigma tau: subst_of subst_of_vl} (E: eq_of_subst sigma tau) : eq_of_subst (cast_vl_tm sigma) (cast_vl_tm tau).
  rename sigma into sigma_vl. rename tau into tau_vl. rename E into E_vl.
  exact (E_vl).
Defined.

Definition eq_cast_vl_ty {sigma tau: subst_of subst_of_vl} (E: eq_of_subst sigma tau) : eq_of_subst (cast_vl_ty sigma) (cast_vl_ty tau).
  rename sigma into sigma_vl. rename tau into tau_vl. rename E into E_vl.
  exact (E_vl).
Defined.

Fixpoint subst_ty (sigma: subst_of subst_of_ty) (s: ty) : ty :=
  match s with
  
  | TNat  => TNat 
  | TAll s0 s1 => TAll ((subst_ty sigma s0)) ((subst_ty (up_ty_vl sigma) s1))
  | TSel s0 => TSel ((subst_vl (cast_ty_vl sigma) s0))
  | TSelA s0 s1 => TSelA ((subst_vl (cast_ty_vl sigma) s0)) ((subst_ty sigma s1))
  | TBind s0 => TBind ((subst_ty (up_ty_vl sigma) s0))
  | TSBind s0 s1 => TSBind ((subst_ty sigma s0)) ((subst_ty (up_ty_vl sigma) s1))
  end
 with subst_tm (sigma: subst_of subst_of_tm) (s: tm) : tm :=
  match s with
  
  | tapp s0 s1 => tapp ((subst_tm sigma s0)) ((subst_tm sigma s1))
  | tlet s0 s1 => tlet ((subst_tm sigma s0)) ((subst_tm (up_tm_vl sigma) s1))
  | tproj s0 => tproj ((subst_tm sigma s0))
  | vt s0 => vt ((subst_vl (cast_tm_vl sigma) s0))
  end
 with subst_vl (sigma: subst_of subst_of_vl) (s: vl) : vl :=
  match s with
  | var_vl x =>  ((toVar_vl sigma) x)
  | vabs s0 => vabs ((subst_tm (up_vl_vl (cast_vl_tm sigma)) s0))
  | vrec s0 => vrec ((subst_tm (up_vl_vl (cast_vl_tm sigma)) s0))
  | vpack s0 s1 => vpack ((subst_ty (cast_vl_ty sigma) s0)) ((subst_tm (cast_vl_tm sigma) s1))
  end.

Definition comp_ty (sigma tau: subst_of subst_of_ty) : subst_of subst_of_ty :=
  match sigma with
  | sigma_vl => fun x => subst_vl (cast_ty_vl tau) (sigma_vl x)
  end.

Definition comp_tm (sigma tau: subst_of subst_of_tm) : subst_of subst_of_tm :=
  match sigma with
  | sigma_vl => fun x => subst_vl (cast_tm_vl tau) (sigma_vl x)
  end.

Definition comp_vl (sigma tau: subst_of subst_of_vl) : subst_of subst_of_vl :=
  match sigma with
  | sigma_vl => fun x => subst_vl tau (sigma_vl x)
  end.

Definition substMixin_ty  : substMixin ty :=
  {|subst_of_substType := subst_of_ty;inst_of_substType := subst_ty|}.

Definition substMixin_tm  : substMixin tm :=
  {|subst_of_substType := subst_of_tm;inst_of_substType := subst_tm|}.

Definition substMixin_vl  : substMixin vl :=
  {|subst_of_substType := subst_of_vl;inst_of_substType := subst_vl|}.

Canonical Structure substType_ty  : substType :=
  Eval hnf in @Pack ty substMixin_ty ty.

Canonical Structure substType_tm  : substType :=
  Eval hnf in @Pack tm substMixin_tm tm.

Canonical Structure substType_vl  : substType :=
  Eval hnf in @Pack vl substMixin_vl vl.

Definition upId_ty_vl (sigma_vl: index -> vl) (E_vl: sigma_vl == var_vl) : @eq_of_subst subst_of_ty (up_ty_vl sigma_vl) var_vl :=
  fun n => match n return (match up_ty_vl sigma_vl with
  | tau_vl => tau_vl n = var_vl  n
  end) with
  | 0 => eq_refl
  | S n => ap (ren_vl (castren_ty_vl S)) (E_vl n)
  end.

Definition upId_tm_vl (sigma_vl: index -> vl) (E_vl: sigma_vl == var_vl) : @eq_of_subst subst_of_tm (up_tm_vl sigma_vl) var_vl :=
  fun n => match n return (match up_tm_vl sigma_vl with
  | tau_vl => tau_vl n = var_vl  n
  end) with
  | 0 => eq_refl
  | S n => ap (ren_vl (castren_tm_vl S)) (E_vl n)
  end.

Definition upId_vl_vl (sigma_vl: index -> vl) (E_vl: sigma_vl == var_vl) : @eq_of_subst subst_of_vl (up_vl_vl sigma_vl) var_vl :=
  fun n => match n return (match up_vl_vl sigma_vl with
  | tau_vl => tau_vl n = var_vl  n
  end) with
  | 0 => eq_refl
  | S n => ap (ren_vl S) (E_vl n)
  end.

Fixpoint id_ty (sigma_vl: index -> vl) (E_vl: sigma_vl == var_vl) (s: ty) : subst_ty sigma_vl s = s :=
  match s with
  
  | TNat  => eq_refl
  | TAll s0 s1 => apc (ap TAll (id_ty _ E_vl s0)) ((match upId_ty_vl _ E_vl with
      | E_vl => id_ty _ E_vl s1
      end))
  | TSel s0 => ap TSel (id_vl _ E_vl s0)
  | TSelA s0 s1 => apc (ap TSelA (id_vl _ E_vl s0)) ((id_ty _ E_vl s1))
  | TBind s0 => ap TBind (match upId_ty_vl _ E_vl with
      | E_vl => id_ty _ E_vl s0
      end)
  | TSBind s0 s1 => apc (ap TSBind (id_ty _ E_vl s0)) ((match upId_ty_vl _ E_vl with
      | E_vl => id_ty _ E_vl s1
      end))
  end
 with id_tm (sigma_vl: index -> vl) (E_vl: sigma_vl == var_vl) (s: tm) : subst_tm sigma_vl s = s :=
  match s with
  
  | tapp s0 s1 => apc (ap tapp (id_tm _ E_vl s0)) ((id_tm _ E_vl s1))
  | tlet s0 s1 => apc (ap tlet (id_tm _ E_vl s0)) ((match upId_tm_vl _ E_vl with
      | E_vl => id_tm _ E_vl s1
      end))
  | tproj s0 => ap tproj (id_tm _ E_vl s0)
  | vt s0 => ap vt (id_vl _ E_vl s0)
  end
 with id_vl (sigma_vl: index -> vl) (E_vl: sigma_vl == var_vl) (s: vl) : subst_vl sigma_vl s = s :=
  match s with
  | var_vl n => E_vl n
  | vabs s0 => ap vabs (match upId_tm_vl _ E_vl with
      | E_vl => id_tm _ E_vl s0
      end)
  | vrec s0 => ap vrec (match upId_tm_vl _ E_vl with
      | E_vl => id_tm _ E_vl s0
      end)
  | vpack s0 s1 => apc (ap vpack (id_ty _ E_vl s0)) ((id_tm _ E_vl s1))
  end.

Definition toSubst_ty (xi: ren_of subst_of_ty) : subst_of subst_of_ty :=
  match xi with
  | xi_vl => fun x => var_vl (xi_vl x)
  end.

Definition toSubst_tm (xi: ren_of subst_of_tm) : subst_of subst_of_tm :=
  match xi with
  | xi_vl => fun x => var_vl (xi_vl x)
  end.

Definition toSubst_vl (xi: ren_of subst_of_vl) : subst_of subst_of_vl :=
  match xi with
  | xi_vl => fun x => var_vl (xi_vl x)
  end.

Fixpoint compTrans_ren_ren_ty (xi_vl zeta_vl theta_vl: ren) (E_vl: funcomp (xi_vl) (zeta_vl) == theta_vl) (s: ty)
           : ren_ty zeta_vl (ren_ty xi_vl s) = ren_ty theta_vl s :=
  match s with
  
  | TNat  => eq_refl
  | TAll s0 s1 =>
      apc (ap TAll (compTrans_ren_ren_ty xi_vl zeta_vl theta_vl E_vl s0)) ((compTrans_ren_ren_ty (up_ren xi_vl) (up_ren zeta_vl) (up_ren theta_vl) (up_ren_ren xi_vl zeta_vl theta_vl E_vl) s1))
  | TSel s0 => ap TSel (compTrans_ren_ren_vl xi_vl zeta_vl theta_vl E_vl s0)
  | TSelA s0 s1 =>
      apc (ap TSelA (compTrans_ren_ren_vl xi_vl zeta_vl theta_vl E_vl s0)) ((compTrans_ren_ren_ty xi_vl zeta_vl theta_vl E_vl s1))
  | TBind s0 =>
      ap TBind (compTrans_ren_ren_ty (up_ren xi_vl) (up_ren zeta_vl) (up_ren theta_vl) (up_ren_ren xi_vl zeta_vl theta_vl E_vl) s0)
  | TSBind s0 s1 =>
      apc (ap TSBind (compTrans_ren_ren_ty xi_vl zeta_vl theta_vl E_vl s0)) ((compTrans_ren_ren_ty (up_ren xi_vl) (up_ren zeta_vl) (up_ren theta_vl) (up_ren_ren xi_vl zeta_vl theta_vl E_vl) s1))
  end
 with compTrans_ren_ren_tm (xi_vl zeta_vl theta_vl: ren) (E_vl: funcomp (xi_vl) (zeta_vl) == theta_vl) (s: tm)
        : ren_tm zeta_vl (ren_tm xi_vl s) = ren_tm theta_vl s :=
  match s with
  
  | tapp s0 s1 =>
      apc (ap tapp (compTrans_ren_ren_tm xi_vl zeta_vl theta_vl E_vl s0)) ((compTrans_ren_ren_tm xi_vl zeta_vl theta_vl E_vl s1))
  | tlet s0 s1 =>
      apc (ap tlet (compTrans_ren_ren_tm xi_vl zeta_vl theta_vl E_vl s0)) ((compTrans_ren_ren_tm (up_ren xi_vl) (up_ren zeta_vl) (up_ren theta_vl) (up_ren_ren xi_vl zeta_vl theta_vl E_vl) s1))
  | tproj s0 => ap tproj (compTrans_ren_ren_tm xi_vl zeta_vl theta_vl E_vl s0)
  | vt s0 => ap vt (compTrans_ren_ren_vl xi_vl zeta_vl theta_vl E_vl s0)
  end
 with compTrans_ren_ren_vl (xi_vl zeta_vl theta_vl: ren) (E_vl: funcomp (xi_vl) (zeta_vl) == theta_vl) (s: vl)
        : ren_vl zeta_vl (ren_vl xi_vl s) = ren_vl theta_vl s :=
  match s with
  | var_vl n => ap var_vl (E_vl n)
  | vabs s0 => ap vabs (compTrans_ren_ren_tm (up_ren xi_vl) (up_ren zeta_vl) (up_ren theta_vl) (up_ren_ren xi_vl zeta_vl theta_vl E_vl) s0)
  | vrec s0 => ap vrec (compTrans_ren_ren_tm (up_ren xi_vl) (up_ren zeta_vl) (up_ren theta_vl) (up_ren_ren xi_vl zeta_vl theta_vl E_vl) s0)
  | vpack s0 s1 =>
      apc (ap vpack (compTrans_ren_ren_ty xi_vl zeta_vl theta_vl E_vl s0)) ((compTrans_ren_ren_tm xi_vl zeta_vl theta_vl E_vl s1))
  end.

Definition compE_ren_ren_ty (xi_vl zeta_vl: ren) (s: ty) : ren_ty zeta_vl (ren_ty xi_vl s) = ren_ty (funcomp xi_vl zeta_vl) s :=
  compTrans_ren_ren_ty xi_vl zeta_vl (funcomp xi_vl zeta_vl) (fun _ => eq_refl) s.

Definition compE_ren_ren_tm (xi_vl zeta_vl: ren) (s: tm) : ren_tm zeta_vl (ren_tm xi_vl s) = ren_tm (funcomp xi_vl zeta_vl) s :=
  compTrans_ren_ren_tm xi_vl zeta_vl (funcomp xi_vl zeta_vl) (fun _ => eq_refl) s.

Definition compE_ren_ren_vl (xi_vl zeta_vl: ren) (s: vl) : ren_vl zeta_vl (ren_vl xi_vl s) = ren_vl (funcomp xi_vl zeta_vl) s :=
  compTrans_ren_ren_vl xi_vl zeta_vl (funcomp xi_vl zeta_vl) (fun _ => eq_refl) s.

Definition up_ren_subst_ty_vl (xi_vl: ren) (theta_vl tau_vl: index -> vl) (E_vl: (fun x =>  theta_vl (xi_vl x)) == tau_vl)
  : @eq_of_subst subst_of_ty (comp_ty (toSubst_ty (upren_ty_vl xi_vl)) (up_ty_vl theta_vl)) (up_ty_vl tau_vl) :=
  fun n => match n return match comp_ty (toSubst_ty (upren_ty_vl xi_vl)) (up_ty_vl theta_vl), up_ty_vl tau_vl with
  | xi_vl, tau_vl => xi_vl n = tau_vl n
  end with
  | 0 => eq_refl
  | S n => ap (ren_vl (castren_ty_vl S)) (E_vl n)
  end.

Definition up_ren_subst_tm_vl (xi_vl: ren) (theta_vl tau_vl: index -> vl) (E_vl: (fun x =>  theta_vl (xi_vl x)) == tau_vl)
  : @eq_of_subst subst_of_tm (comp_tm (toSubst_tm (upren_tm_vl xi_vl)) (up_tm_vl theta_vl)) (up_tm_vl tau_vl) :=
  fun n => match n return match comp_tm (toSubst_tm (upren_tm_vl xi_vl)) (up_tm_vl theta_vl), up_tm_vl tau_vl with
  | xi_vl, tau_vl => xi_vl n = tau_vl n
  end with
  | 0 => eq_refl
  | S n => ap (ren_vl (castren_tm_vl S)) (E_vl n)
  end.

Definition up_ren_subst_vl_vl (xi_vl: ren) (theta_vl tau_vl: index -> vl) (E_vl: (fun x =>  theta_vl (xi_vl x)) == tau_vl)
  : @eq_of_subst subst_of_vl (comp_vl (toSubst_vl (upren_vl_vl xi_vl)) (up_vl_vl theta_vl)) (up_vl_vl tau_vl) :=
  fun n => match n return match comp_vl (toSubst_vl (upren_vl_vl xi_vl)) (up_vl_vl theta_vl), up_vl_vl tau_vl with
  | xi_vl, tau_vl => xi_vl n = tau_vl n
  end with
  | 0 => eq_refl
  | S n => ap (ren_vl S) (E_vl n)
  end.

Fixpoint compTrans_ren_subst_ty (xi_vl: ren) (tau_vl theta_vl: index -> vl) (E_vl: (fun x =>  tau_vl (xi_vl x)) == theta_vl) (s: ty)
           : subst_ty tau_vl (ren_ty xi_vl s) = subst_ty theta_vl s :=
  match s with
  
  | TNat  => eq_refl
  | TAll s0 s1 => apc (ap TAll (compTrans_ren_subst_ty xi_vl _ _ E_vl s0)) ((match up_ren_subst_ty_vl xi_vl tau_vl theta_vl E_vl with
      | E_vl => compTrans_ren_subst_ty (up_ren xi_vl) _ _ E_vl s1
      end))
  | TSel s0 => ap TSel (compTrans_ren_subst_vl xi_vl _ _ E_vl s0)
  | TSelA s0 s1 => apc (ap TSelA (compTrans_ren_subst_vl xi_vl _ _ E_vl s0)) ((compTrans_ren_subst_ty xi_vl _ _ E_vl s1))
  | TBind s0 => ap TBind (match up_ren_subst_ty_vl xi_vl tau_vl theta_vl E_vl with
      | E_vl => compTrans_ren_subst_ty (up_ren xi_vl) _ _ E_vl s0
      end)
  | TSBind s0 s1 => apc (ap TSBind (compTrans_ren_subst_ty xi_vl _ _ E_vl s0)) ((match up_ren_subst_ty_vl xi_vl tau_vl theta_vl E_vl with
      | E_vl => compTrans_ren_subst_ty (up_ren xi_vl) _ _ E_vl s1
      end))
  end
 with compTrans_ren_subst_tm (xi_vl: ren) (tau_vl theta_vl: index -> vl) (E_vl: (fun x =>  tau_vl (xi_vl x)) == theta_vl) (s: tm)
        : subst_tm tau_vl (ren_tm xi_vl s) = subst_tm theta_vl s :=
  match s with
  
  | tapp s0 s1 => apc (ap tapp (compTrans_ren_subst_tm xi_vl _ _ E_vl s0)) ((compTrans_ren_subst_tm xi_vl _ _ E_vl s1))
  | tlet s0 s1 => apc (ap tlet (compTrans_ren_subst_tm xi_vl _ _ E_vl s0)) ((match up_ren_subst_tm_vl xi_vl tau_vl theta_vl E_vl with
      | E_vl => compTrans_ren_subst_tm (up_ren xi_vl) _ _ E_vl s1
      end))
  | tproj s0 => ap tproj (compTrans_ren_subst_tm xi_vl _ _ E_vl s0)
  | vt s0 => ap vt (compTrans_ren_subst_vl xi_vl _ _ E_vl s0)
  end
 with compTrans_ren_subst_vl (xi_vl: ren) (tau_vl theta_vl: index -> vl) (E_vl: (fun x =>  tau_vl (xi_vl x)) == theta_vl) (s: vl)
        : subst_vl tau_vl (ren_vl xi_vl s) = subst_vl theta_vl s :=
  match s with
  | var_vl n =>  (E_vl n)
  | vabs s0 => ap vabs (match up_ren_subst_vl_vl xi_vl tau_vl theta_vl E_vl with
      | E_vl => compTrans_ren_subst_tm (up_ren xi_vl) _ _ E_vl s0
      end)
  | vrec s0 => ap vrec (match up_ren_subst_vl_vl xi_vl tau_vl theta_vl E_vl with
      | E_vl => compTrans_ren_subst_tm (up_ren xi_vl) _ _ E_vl s0
      end)
  | vpack s0 s1 => apc (ap vpack (compTrans_ren_subst_ty xi_vl _ _ E_vl s0)) ((compTrans_ren_subst_tm xi_vl _ _ E_vl s1))
  end.

Definition compE_ren_subst_ty (xi_vl: ren) (tau_vl: index -> vl) (s: ty)
  : subst_ty tau_vl (ren_ty xi_vl s) = subst_ty (funcomp xi_vl tau_vl) s :=
  compTrans_ren_subst_ty xi_vl tau_vl (funcomp xi_vl tau_vl) (fun _ => eq_refl) s.

Definition compE_ren_subst_tm (xi_vl: ren) (tau_vl: index -> vl) (s: tm)
  : subst_tm tau_vl (ren_tm xi_vl s) = subst_tm (funcomp xi_vl tau_vl) s :=
  compTrans_ren_subst_tm xi_vl tau_vl (funcomp xi_vl tau_vl) (fun _ => eq_refl) s.

Definition compE_ren_subst_vl (xi_vl: ren) (tau_vl: index -> vl) (s: vl)
  : subst_vl tau_vl (ren_vl xi_vl s) = subst_vl (funcomp xi_vl tau_vl) s :=
  compTrans_ren_subst_vl xi_vl tau_vl (funcomp xi_vl tau_vl) (fun _ => eq_refl) s.

Definition up_subst_ren_ty_vl (sigma_vl: index -> vl)
  (rho_vl: ren)
  (tau_vl: index -> vl)
  (E_vl: (fun x =>  ren_vl rho_vl (sigma_vl x)) == tau_vl)
  : @eq_of_subst subst_of_ty (compren_ty (up_ty_vl sigma_vl) (upren_ty_vl rho_vl)) (up_ty_vl tau_vl) :=
  fun n => match n return match compren_ty (up_ty_vl sigma_vl) (upren_ty_vl rho_vl), up_ty_vl tau_vl with
  | sigma_vl, tau_vl => sigma_vl n = tau_vl n
  end with
  | 0 => eq_refl
  | S n =>
      eq_trans (compE_ren_ren_vl S (up_ren rho_vl) (sigma_vl n)) (eq_trans (eq_sym (compE_ren_ren_vl rho_vl S (sigma_vl n))) (ap (ren_vl S) (E_vl n)))
  end.

Definition up_subst_ren_tm_vl (sigma_vl: index -> vl)
  (rho_vl: ren)
  (tau_vl: index -> vl)
  (E_vl: (fun x =>  ren_vl rho_vl (sigma_vl x)) == tau_vl)
  : @eq_of_subst subst_of_tm (compren_tm (up_tm_vl sigma_vl) (upren_tm_vl rho_vl)) (up_tm_vl tau_vl) :=
  fun n => match n return match compren_tm (up_tm_vl sigma_vl) (upren_tm_vl rho_vl), up_tm_vl tau_vl with
  | sigma_vl, tau_vl => sigma_vl n = tau_vl n
  end with
  | 0 => eq_refl
  | S n =>
      eq_trans (compE_ren_ren_vl S (up_ren rho_vl) (sigma_vl n)) (eq_trans (eq_sym (compE_ren_ren_vl rho_vl S (sigma_vl n))) (ap (ren_vl S) (E_vl n)))
  end.

Definition up_subst_ren_vl_vl (sigma_vl: index -> vl)
  (rho_vl: ren)
  (tau_vl: index -> vl)
  (E_vl: (fun x =>  ren_vl rho_vl (sigma_vl x)) == tau_vl)
  : @eq_of_subst subst_of_vl (compren_vl (up_vl_vl sigma_vl) (upren_vl_vl rho_vl)) (up_vl_vl tau_vl) :=
  fun n => match n return match compren_vl (up_vl_vl sigma_vl) (upren_vl_vl rho_vl), up_vl_vl tau_vl with
  | sigma_vl, tau_vl => sigma_vl n = tau_vl n
  end with
  | 0 => eq_refl
  | S n =>
      eq_trans (compE_ren_ren_vl S (up_ren rho_vl) (sigma_vl n)) (eq_trans (eq_sym (compE_ren_ren_vl rho_vl S (sigma_vl n))) (ap (ren_vl S) (E_vl n)))
  end.

Fixpoint compTrans_subst_ren_ty (sigma_vl: index -> vl)
           (zeta_vl: ren)
           (theta_vl: index -> vl)
           (E_vl: (fun x =>  ren_vl zeta_vl (sigma_vl x)) == theta_vl)
           (s: ty) : ren_ty zeta_vl (subst_ty sigma_vl s) = subst_ty theta_vl s :=
  match s with
  
  | TNat  => eq_refl
  | TAll s0 s1 => apc (ap TAll (compTrans_subst_ren_ty _ zeta_vl _ E_vl s0)) ((match up_subst_ren_ty_vl sigma_vl zeta_vl theta_vl E_vl with
      | E_vl => compTrans_subst_ren_ty _ (up_ren zeta_vl) _ E_vl s1
      end))
  | TSel s0 => ap TSel (compTrans_subst_ren_vl _ zeta_vl _ E_vl s0)
  | TSelA s0 s1 => apc (ap TSelA (compTrans_subst_ren_vl _ zeta_vl _ E_vl s0)) ((compTrans_subst_ren_ty _ zeta_vl _ E_vl s1))
  | TBind s0 => ap TBind (match up_subst_ren_ty_vl sigma_vl zeta_vl theta_vl E_vl with
      | E_vl => compTrans_subst_ren_ty _ (up_ren zeta_vl) _ E_vl s0
      end)
  | TSBind s0 s1 =>
      apc (ap TSBind (compTrans_subst_ren_ty _ zeta_vl _ E_vl s0)) ((match up_subst_ren_ty_vl sigma_vl zeta_vl theta_vl E_vl with
      | E_vl => compTrans_subst_ren_ty _ (up_ren zeta_vl) _ E_vl s1
      end))
  end
 with compTrans_subst_ren_tm (sigma_vl: index -> vl)
        (zeta_vl: ren)
        (theta_vl: index -> vl)
        (E_vl: (fun x =>  ren_vl zeta_vl (sigma_vl x)) == theta_vl)
        (s: tm) : ren_tm zeta_vl (subst_tm sigma_vl s) = subst_tm theta_vl s :=
  match s with
  
  | tapp s0 s1 => apc (ap tapp (compTrans_subst_ren_tm _ zeta_vl _ E_vl s0)) ((compTrans_subst_ren_tm _ zeta_vl _ E_vl s1))
  | tlet s0 s1 => apc (ap tlet (compTrans_subst_ren_tm _ zeta_vl _ E_vl s0)) ((match up_subst_ren_tm_vl sigma_vl zeta_vl theta_vl E_vl with
      | E_vl => compTrans_subst_ren_tm _ (up_ren zeta_vl) _ E_vl s1
      end))
  | tproj s0 => ap tproj (compTrans_subst_ren_tm _ zeta_vl _ E_vl s0)
  | vt s0 => ap vt (compTrans_subst_ren_vl _ zeta_vl _ E_vl s0)
  end
 with compTrans_subst_ren_vl (sigma_vl: index -> vl)
        (zeta_vl: ren)
        (theta_vl: index -> vl)
        (E_vl: (fun x =>  ren_vl zeta_vl (sigma_vl x)) == theta_vl)
        (s: vl) : ren_vl zeta_vl (subst_vl sigma_vl s) = subst_vl theta_vl s :=
  match s with
  | var_vl n =>  (E_vl n)
  | vabs s0 => ap vabs (match up_subst_ren_vl_vl sigma_vl zeta_vl theta_vl E_vl with
      | E_vl => compTrans_subst_ren_tm _ (up_ren zeta_vl) _ E_vl s0
      end)
  | vrec s0 => ap vrec (match up_subst_ren_vl_vl sigma_vl zeta_vl theta_vl E_vl with
      | E_vl => compTrans_subst_ren_tm _ (up_ren zeta_vl) _ E_vl s0
      end)
  | vpack s0 s1 => apc (ap vpack (compTrans_subst_ren_ty _ zeta_vl _ E_vl s0)) ((compTrans_subst_ren_tm _ zeta_vl _ E_vl s1))
  end.

Definition compE_subst_ren_ty (sigma_vl: index -> vl) (zeta_vl: ren) (s: ty)
  : ren_ty zeta_vl (subst_ty sigma_vl s) = subst_ty (fun n => ren_vl (zeta_vl) (sigma_vl n)) s :=
  compTrans_subst_ren_ty sigma_vl zeta_vl (fun n => ren_vl (zeta_vl) (sigma_vl n)) (fun _ => eq_refl) s.

Definition compE_subst_ren_tm (sigma_vl: index -> vl) (zeta_vl: ren) (s: tm)
  : ren_tm zeta_vl (subst_tm sigma_vl s) = subst_tm (fun n => ren_vl (zeta_vl) (sigma_vl n)) s :=
  compTrans_subst_ren_tm sigma_vl zeta_vl (fun n => ren_vl (zeta_vl) (sigma_vl n)) (fun _ => eq_refl) s.

Definition compE_subst_ren_vl (sigma_vl: index -> vl) (zeta_vl: ren) (s: vl)
  : ren_vl zeta_vl (subst_vl sigma_vl s) = subst_vl (fun n => ren_vl (zeta_vl) (sigma_vl n)) s :=
  compTrans_subst_ren_vl sigma_vl zeta_vl (fun n => ren_vl (zeta_vl) (sigma_vl n)) (fun _ => eq_refl) s.

Definition up_subst_subst_ty_vl (sigma_vl theta_vl tau_vl: index -> vl) (E_vl: (fun x =>  subst_vl theta_vl (sigma_vl x)) == tau_vl)
  : @eq_of_subst subst_of_ty (comp_ty (up_ty_vl sigma_vl) (up_ty_vl theta_vl)) (up_ty_vl tau_vl) :=
  fun n => match n return match comp_ty (up_ty_vl sigma_vl) (up_ty_vl theta_vl), up_ty_vl tau_vl with
  | sigma_vl, tau_vl => sigma_vl n = tau_vl n
  end with
  | 0 => eq_refl
  | S n =>
      eq_trans (compE_ren_subst_vl S _ (sigma_vl n)) (eq_trans (eq_sym (compE_subst_ren_vl theta_vl S (sigma_vl n))) (ap (ren_vl S) (E_vl n)))
  end.

Definition up_subst_subst_tm_vl (sigma_vl theta_vl tau_vl: index -> vl) (E_vl: (fun x =>  subst_vl theta_vl (sigma_vl x)) == tau_vl)
  : @eq_of_subst subst_of_tm (comp_tm (up_tm_vl sigma_vl) (up_tm_vl theta_vl)) (up_tm_vl tau_vl) :=
  fun n => match n return match comp_tm (up_tm_vl sigma_vl) (up_tm_vl theta_vl), up_tm_vl tau_vl with
  | sigma_vl, tau_vl => sigma_vl n = tau_vl n
  end with
  | 0 => eq_refl
  | S n =>
      eq_trans (compE_ren_subst_vl S _ (sigma_vl n)) (eq_trans (eq_sym (compE_subst_ren_vl theta_vl S (sigma_vl n))) (ap (ren_vl S) (E_vl n)))
  end.

Definition up_subst_subst_vl_vl (sigma_vl theta_vl tau_vl: index -> vl) (E_vl: (fun x =>  subst_vl theta_vl (sigma_vl x)) == tau_vl)
  : @eq_of_subst subst_of_vl (comp_vl (up_vl_vl sigma_vl) (up_vl_vl theta_vl)) (up_vl_vl tau_vl) :=
  fun n => match n return match comp_vl (up_vl_vl sigma_vl) (up_vl_vl theta_vl), up_vl_vl tau_vl with
  | sigma_vl, tau_vl => sigma_vl n = tau_vl n
  end with
  | 0 => eq_refl
  | S n =>
      eq_trans (compE_ren_subst_vl S _ (sigma_vl n)) (eq_trans (eq_sym (compE_subst_ren_vl theta_vl S (sigma_vl n))) (ap (ren_vl S) (E_vl n)))
  end.

Fixpoint compTrans_subst_subst_ty (sigma_vl tau_vl theta_vl: index -> vl)
           (E_vl: (fun x =>  subst_vl tau_vl (sigma_vl x)) == theta_vl)
           (s: ty) : subst_ty tau_vl (subst_ty sigma_vl s) = subst_ty theta_vl s :=
  match s with
  
  | TNat  => eq_refl
  | TAll s0 s1 => apc (ap TAll (compTrans_subst_subst_ty _ _ _ E_vl s0)) ((match up_subst_subst_ty_vl sigma_vl tau_vl theta_vl E_vl with
      | E_vl => compTrans_subst_subst_ty _ _ _ E_vl s1
      end))
  | TSel s0 => ap TSel (compTrans_subst_subst_vl _ _ _ E_vl s0)
  | TSelA s0 s1 => apc (ap TSelA (compTrans_subst_subst_vl _ _ _ E_vl s0)) ((compTrans_subst_subst_ty _ _ _ E_vl s1))
  | TBind s0 => ap TBind (match up_subst_subst_ty_vl sigma_vl tau_vl theta_vl E_vl with
      | E_vl => compTrans_subst_subst_ty _ _ _ E_vl s0
      end)
  | TSBind s0 s1 => apc (ap TSBind (compTrans_subst_subst_ty _ _ _ E_vl s0)) ((match up_subst_subst_ty_vl sigma_vl tau_vl theta_vl E_vl with
      | E_vl => compTrans_subst_subst_ty _ _ _ E_vl s1
      end))
  end
 with compTrans_subst_subst_tm (sigma_vl tau_vl theta_vl: index -> vl) (E_vl: (fun x =>  subst_vl tau_vl (sigma_vl x)) == theta_vl) (s: tm)
        : subst_tm tau_vl (subst_tm sigma_vl s) = subst_tm theta_vl s :=
  match s with
  
  | tapp s0 s1 => apc (ap tapp (compTrans_subst_subst_tm _ _ _ E_vl s0)) ((compTrans_subst_subst_tm _ _ _ E_vl s1))
  | tlet s0 s1 => apc (ap tlet (compTrans_subst_subst_tm _ _ _ E_vl s0)) ((match up_subst_subst_tm_vl sigma_vl tau_vl theta_vl E_vl with
      | E_vl => compTrans_subst_subst_tm _ _ _ E_vl s1
      end))
  | tproj s0 => ap tproj (compTrans_subst_subst_tm _ _ _ E_vl s0)
  | vt s0 => ap vt (compTrans_subst_subst_vl _ _ _ E_vl s0)
  end
 with compTrans_subst_subst_vl (sigma_vl tau_vl theta_vl: index -> vl) (E_vl: (fun x =>  subst_vl tau_vl (sigma_vl x)) == theta_vl) (s: vl)
        : subst_vl tau_vl (subst_vl sigma_vl s) = subst_vl theta_vl s :=
  match s with
  | var_vl n =>  (E_vl n)
  | vabs s0 => ap vabs (match up_subst_subst_vl_vl sigma_vl tau_vl theta_vl E_vl with
      | E_vl => compTrans_subst_subst_tm _ _ _ E_vl s0
      end)
  | vrec s0 => ap vrec (match up_subst_subst_vl_vl sigma_vl tau_vl theta_vl E_vl with
      | E_vl => compTrans_subst_subst_tm _ _ _ E_vl s0
      end)
  | vpack s0 s1 => apc (ap vpack (compTrans_subst_subst_ty _ _ _ E_vl s0)) ((compTrans_subst_subst_tm _ _ _ E_vl s1))
  end.

Definition compE_subst_subst_ty (sigma_vl tau_vl: index -> vl) (s: ty)
  : subst_ty tau_vl (subst_ty sigma_vl s) = subst_ty (fun n => subst_vl (tau_vl) (sigma_vl n)) s :=
  compTrans_subst_subst_ty sigma_vl tau_vl (fun n => subst_vl (tau_vl) (sigma_vl n)) (fun _ => eq_refl) s.

Definition compE_subst_subst_tm (sigma_vl tau_vl: index -> vl) (s: tm)
  : subst_tm tau_vl (subst_tm sigma_vl s) = subst_tm (fun n => subst_vl (tau_vl) (sigma_vl n)) s :=
  compTrans_subst_subst_tm sigma_vl tau_vl (fun n => subst_vl (tau_vl) (sigma_vl n)) (fun _ => eq_refl) s.

Definition compE_subst_subst_vl (sigma_vl tau_vl: index -> vl) (s: vl)
  : subst_vl tau_vl (subst_vl sigma_vl s) = subst_vl (fun n => subst_vl (tau_vl) (sigma_vl n)) s :=
  compTrans_subst_subst_vl sigma_vl tau_vl (fun n => subst_vl (tau_vl) (sigma_vl n)) (fun _ => eq_refl) s.

Definition eq_up_ty_vl {sigma tau: subst_of subst_of_ty} (E: eq_of_subst sigma tau) : eq_of_subst (up_ty_vl sigma) (up_ty_vl tau).
  rename sigma into sigma_vl. rename tau into tau_vl. rename E into E_vl.
  exact (fun i: index => match i return (var_vl 0 .: sigma_vl >>> ren_vl (castren_ty_vl S)) i = (var_vl 0 .: tau_vl >>> ren_vl (castren_ty_vl S)) i
  with 0 => eq_refl | S j => ap _ (E_vl j) end).
Defined.

Definition eq_up_tm_vl {sigma tau: subst_of subst_of_tm} (E: eq_of_subst sigma tau) : eq_of_subst (up_tm_vl sigma) (up_tm_vl tau).
  rename sigma into sigma_vl. rename tau into tau_vl. rename E into E_vl.
  exact (fun i: index => match i return (var_vl 0 .: sigma_vl >>> ren_vl (castren_tm_vl S)) i = (var_vl 0 .: tau_vl >>> ren_vl (castren_tm_vl S)) i
  with 0 => eq_refl | S j => ap _ (E_vl j) end).
Defined.

Definition eq_up_vl_vl {sigma tau: subst_of subst_of_vl} (E: eq_of_subst sigma tau) : eq_of_subst (up_vl_vl sigma) (up_vl_vl tau).
  rename sigma into sigma_vl. rename tau into tau_vl. rename E into E_vl.
  exact (fun i: index => match i return (var_vl 0 .: sigma_vl >>> ren_vl S) i = (var_vl 0 .: tau_vl >>> ren_vl S) i with 0 => eq_refl
                                                                                                                     | S j => ap _ (E_vl j) end).
Defined.

Fixpoint subst_eq_ty {sigma tau: subst_of subst_of_ty} (E: eq_of_subst sigma tau) (s: ty) : subst_ty sigma s = subst_ty tau s :=
  match s with
  
  | TNat  => congr_TNat 
  | TAll s0 s1 => congr_TAll (subst_eq_ty E s0) (subst_eq_ty (eq_up_ty_vl E) s1)
  | TSel s0 => congr_TSel (subst_eq_vl (eq_cast_ty_vl E) s0)
  | TSelA s0 s1 => congr_TSelA (subst_eq_vl (eq_cast_ty_vl E) s0) (subst_eq_ty E s1)
  | TBind s0 => congr_TBind (subst_eq_ty (eq_up_ty_vl E) s0)
  | TSBind s0 s1 => congr_TSBind (subst_eq_ty E s0) (subst_eq_ty (eq_up_ty_vl E) s1)
  end
 with subst_eq_tm {sigma tau: subst_of subst_of_tm} (E: eq_of_subst sigma tau) (s: tm) : subst_tm sigma s = subst_tm tau s :=
  match s with
  
  | tapp s0 s1 => congr_tapp (subst_eq_tm E s0) (subst_eq_tm E s1)
  | tlet s0 s1 => congr_tlet (subst_eq_tm E s0) (subst_eq_tm (eq_up_tm_vl E) s1)
  | tproj s0 => congr_tproj (subst_eq_tm E s0)
  | vt s0 => congr_vt (subst_eq_vl (eq_cast_tm_vl E) s0)
  end
 with subst_eq_vl {sigma tau: subst_of subst_of_vl} (E: eq_of_subst sigma tau) (s: vl) : subst_vl sigma s = subst_vl tau s :=
  match s with
  | var_vl n => eq_toVar_vl E n
  | vabs s0 => congr_vabs (subst_eq_tm (eq_up_tm_vl (eq_cast_vl_tm E)) s0)
  | vrec s0 => congr_vrec (subst_eq_tm (eq_up_tm_vl (eq_cast_vl_tm E)) s0)
  | vpack s0 s1 => congr_vpack (subst_eq_ty (eq_cast_vl_ty E) s0) (subst_eq_tm (eq_cast_vl_tm E) s1)
  end.

Class AsimplInst_ty (s: ty) (sigma: subst_of subst_of_ty) (t: ty) := asimplInstEqn_ty : (subst_ty sigma) s = t .
Hint Mode AsimplInst_ty + + - : typeclass_instance.

Class AsimplSubst_ty (sigma tau: subst_of subst_of_ty) := asimplSubstEqn_ty : match sigma, tau with
| sigma_vl, tau_vl => (forall x, sigma_vl x = tau_vl x)
end .
Hint Mode AsimplSubst_ty + - : typeclass_instance.

Class AsimplComp_ty (sigma tau theta: subst_of subst_of_ty) := asimplCompEqn_ty : match comp_ty sigma tau, theta with
| sigma_tau_vl, theta_vl => (forall x, sigma_tau_vl x = theta_vl x)
end .
Hint Mode AsimplComp_ty + + - : typeclass_instance.

Class AsimplInst_tm (s: tm) (sigma: subst_of subst_of_tm) (t: tm) := asimplInstEqn_tm : (subst_tm sigma) s = t .
Hint Mode AsimplInst_tm + + - : typeclass_instance.

Class AsimplSubst_tm (sigma tau: subst_of subst_of_tm) := asimplSubstEqn_tm : match sigma, tau with
| sigma_vl, tau_vl => (forall x, sigma_vl x = tau_vl x)
end .
Hint Mode AsimplSubst_tm + - : typeclass_instance.

Class AsimplComp_tm (sigma tau theta: subst_of subst_of_tm) := asimplCompEqn_tm : match comp_tm sigma tau, theta with
| sigma_tau_vl, theta_vl => (forall x, sigma_tau_vl x = theta_vl x)
end .
Hint Mode AsimplComp_tm + + - : typeclass_instance.

Class AsimplInst_vl (s: vl) (sigma: subst_of subst_of_vl) (t: vl) := asimplInstEqn_vl : (subst_vl sigma) s = t .
Hint Mode AsimplInst_vl + + - : typeclass_instance.

Class AsimplSubst_vl (sigma tau: subst_of subst_of_vl) := asimplSubstEqn_vl : match sigma, tau with
| sigma_vl, tau_vl => (forall x, sigma_vl x = tau_vl x)
end .
Hint Mode AsimplSubst_vl + - : typeclass_instance.

Class AsimplComp_vl (sigma tau theta: subst_of subst_of_vl) := asimplCompEqn_vl : match comp_vl sigma tau, theta with
| sigma_tau_vl, theta_vl => (forall x, sigma_tau_vl x = theta_vl x)
end .
Hint Mode AsimplComp_vl + + - : typeclass_instance.

Instance AsimplCast_ty_vl (sigma_vl: index -> vl)
(tau: subst_of subst_of_vl)
(E: AsimplSubst_vl sigma_vl tau) : AsimplSubst_vl ((cast_ty_vl sigma_vl)) tau.
Proof. apply E. Qed.
Typeclasses Opaque cast_ty_vl.



Instance AsimplAsimplInst_ty (s t: ty)
(sigma sigma': subst_of subst_of_ty)
(E_sigma: AsimplSubst_ty sigma sigma')
(E: AsimplInst_ty s sigma' t) : Asimpl (subst_ty sigma s) t.
Proof. rewrite <- E. apply subst_eq_ty. assumption. Qed.

Instance AsimplInstRefl_ty (s: ty) (sigma: subst_of subst_of_ty) : AsimplInst_ty s sigma (s.[ sigma ]) |100.
Proof. reflexivity. Qed.



Instance asimplInst_TNat (sigma: subst_of subst_of_ty) : AsimplInst_ty (TNat ) sigma (TNat ).
reflexivity. Qed.

Hint Resolve subst_eq_ty subst_eq_vl subst_eq_tm.
Instance asimplInst_TAll (s0 s1 s0' s1': _)
(sigma theta_0 theta_1: subst_of subst_of_ty)
(E_0': AsimplSubst_ty (sigma) theta_0)
(E_1': AsimplSubst_ty ((up_ty_vl sigma)) theta_1)
(E_0: AsimplInst_ty s0 theta_0 s0')
(E_1: AsimplInst_ty s1 theta_1 s1') : AsimplInst_ty (TAll s0 s1) sigma (TAll s0' s1').
Proof. hnf; cbn; rewrite <- E_0, <- E_1. f_equal; auto. Qed.

Instance asimplInst_TSel (s0 s0': _)
(sigma: subst_of subst_of_ty)
(theta_0: subst_of subst_of_vl)
(E_0': AsimplSubst_vl (((cast_ty_vl sigma))) theta_0)
(E_0: AsimplInst_vl s0 theta_0 s0') : AsimplInst_ty (TSel s0) sigma (TSel s0').
Proof. hnf; cbn. rewrite <- E_0. f_equal; auto. Qed.

Instance asimplInst_TSelA (s0 s1 s0' s1': _)
(sigma: subst_of subst_of_ty)
(theta_0: subst_of subst_of_vl)
(theta_1: subst_of subst_of_ty)
(E_0': AsimplSubst_vl (((cast_ty_vl sigma))) theta_0)
(E_1': AsimplSubst_ty (sigma) theta_1)
(E_0: AsimplInst_vl s0 theta_0 s0')
(E_1: AsimplInst_ty s1 theta_1 s1') : AsimplInst_ty (TSelA s0 s1) sigma (TSelA s0' s1').
Proof. hnf; cbn. rewrite <- E_0, <- E_1. f_equal; auto. Qed.

Instance asimplInst_TBind (s0 s0': _)
(sigma theta_0: subst_of subst_of_ty)
(E_0': AsimplSubst_ty ((up_ty_vl sigma)) theta_0)
(E_0: AsimplInst_ty s0 theta_0 s0') : AsimplInst_ty (TBind s0) sigma (TBind s0').
Proof. hnf; cbn. rewrite <- E_0. f_equal; auto. Qed.

Instance asimplInst_TSBind (s0 s1 s0' s1': _)
(sigma theta_0 theta_1: subst_of subst_of_ty)
(E_0': AsimplSubst_ty (sigma) theta_0)
(E_1': AsimplSubst_ty ((up_ty_vl sigma)) theta_1)
(E_0: AsimplInst_ty s0 theta_0 s0')
(E_1: AsimplInst_ty s1 theta_1 s1') : AsimplInst_ty (TSBind s0 s1) sigma (TSBind s0' s1').
Proof. hnf; cbn. rewrite <- E_0, <- E_1. f_equal; auto. Qed.

Instance AsimplId_ty (s: ty) : AsimplInst_ty s var_vl s.
Proof. apply id_ty; reflexivity. Qed.

Instance AsimplInstInst_ty (s t: ty)
(sigma sigma' tau sigma_tau: subst_of subst_of_ty)
(E1: AsimplSubst_ty sigma sigma')
(E2: AsimplComp_ty sigma' tau sigma_tau)
(E3: AsimplInst_ty s sigma_tau t) : AsimplInst_ty (subst_ty sigma s) tau t.
Proof. 
       rewrite <- E3. apply compTrans_subst_subst_ty; intros.
       rewrite E1. apply E2.
Qed.

Instance AsimplSubstRefl_ty (sigma: subst_of subst_of_ty) : AsimplSubst_ty sigma sigma | 100.
Proof. intro. reflexivity. Qed.

Instance AsimplSubstComp_ty (sigma sigma' tau tau' theta: subst_of subst_of_ty)
(E_sigma: AsimplSubst_ty sigma sigma')
(E_tau: AsimplSubst_ty tau tau')
(E: AsimplComp_ty sigma' tau' theta) : AsimplSubst_ty (comp_ty sigma tau) theta |90.
Proof.
  intros x. rewrite <- E. unfold comp_ty.
  rewrite E_sigma. auto.
Qed. 

Instance AsimplSubstCongr_ty (sigma_vl tau_vl: index -> vl) (E_vl: AsimplGen sigma_vl tau_vl) : AsimplSubst_ty sigma_vl tau_vl |95.
Proof. repeat split; assumption. Qed.

Instance AsimplCompRefl_ty (sigma tau: subst_of subst_of_ty) : AsimplComp_ty sigma tau (comp_ty sigma tau) | 100.
Proof. intro. reflexivity. Qed. 

Instance AsimplCompIdR_ty (sigma: index -> ty) : AsimplComp sigma (subst_ty var_vl) sigma.
Proof. intros x. apply id_ty; reflexivity. Qed.

Instance AsimplCompAsso_ty (sigma tau theta tau_theta sigma_tau_theta: subst_of subst_of_ty)
(E: AsimplComp_ty tau theta tau_theta)
(E': AsimplComp_ty sigma tau_theta sigma_tau_theta) : AsimplComp_ty (comp_ty sigma tau) theta sigma_tau_theta.
Proof. intro. rewrite <- E'. unfold comp_ty. erewrite compTrans_subst_subst_vl; auto. Qed.

Instance AsimplCompCongr_ty (sigma_vl theta_vl: index -> vl)
(tau_vl: subst_of subst_of_vl)
(tau: subst_of subst_of_ty)
(E_vl: AsimplSubst_vl ((cast_ty_vl tau)) tau_vl)
(E_vl': AsimplComp sigma_vl (subst_vl tau_vl) theta_vl) : AsimplComp_ty sigma_vl tau theta_vl.
Proof.
  intro. rewrite <- E_vl'. simpl. apply subst_eq_vl. assumption. 
Qed. 

Instance AsimplCompCongr'_ty (sigma_vl theta_vl: index -> vl)
(tau_vl: subst_of subst_of_vl)
(tau: subst_of subst_of_ty)
(E_vl: AsimplSubst_vl ((cast_ty_vl tau)) tau_vl)
(E_vl': AsimplComp sigma_vl (subst_vl tau_vl) theta_vl) : AsimplComp (subst_ty sigma_vl) (subst_ty tau) (subst_ty theta_vl).
Proof.
  intros s. simpl.
  erewrite AsimplInstInst_ty.
  - reflexivity.
  - intro. reflexivity.
  - intro. rewrite <- E_vl'. apply subst_eq_vl. assumption.  
  - reflexivity. 
Qed. 

Instance AsimplRefl_ty (s: ty) : Asimpl s s | 100.
Proof. reflexivity. Qed.

Instance AsimplGenComp_ty (sigma sigma': index -> ty)
(tau tau': subst_of subst_of_ty)
(theta: index -> ty)
(E: AsimplGen sigma sigma')
(E': AsimplSubst_ty tau tau')
(E'': AsimplComp sigma' (subst_ty tau') theta) : AsimplGen (sigma >>> (subst_ty tau) ) theta.
Proof. intros x. rewrite <- E''. simpl. rewrite E. now apply subst_eq_ty . Qed.

Lemma up_ren_up (xi : ren) (sigma : index -> vl) (E : (xi >>> var_vl) == sigma) :
  (upren_vl_vl xi >>> var_vl) == up_vl_vl sigma. 
Proof.
  intros [|x].
  - reflexivity.
  - simpl. unfold compren_vl. rewrite <- E. reflexivity.
Qed.
  
Hint Resolve up_ren_up.

(* *Statement* and proof written by hand! *)
(* Lemma ren_inst_ty_vl (xi : ren) (sigma : index -> vl) (s : ty) (E : (xi >>> var_vl) == sigma) : *)
(*   ren_ty xi s = s.[sigma]. *)
Fixpoint ren_inst_vl_vl (xi : ren) (sigma : index -> vl)  (E : (xi >>> var_vl) == sigma) (s : vl) :
  ren_vl xi s = s.[sigma]
with ren_inst_vl_tm (xi : ren) (sigma : index -> vl)  (E : (xi >>> var_vl) == sigma) (s : tm):
  ren_tm xi s = s.[sigma]
with ren_inst_vl_ty (xi : ren) (sigma : index -> vl)  (E : (xi >>> var_vl) == sigma) (s : ty):
  ren_ty xi s = s.[sigma].
Proof.
  (* - induction s; cbn; f_equal; try assumption. *)
  (*   + apply E. *)
  (*   + erewrite ren_inst_vl_tm with (sigma := up_vl_vl sigma); eauto. *)
  (*     (* * *) *)
  (*     (*   unfold castren_vl_tm. *) *)
  (*     (*   intro. Check up_ren_up. *) *)
  (*     (*   auto. intro. cbn. *) *)
  (*     (*   (* unfold upren_vl_vl. *) *) *)

  (*     (*   apply up_ren_up. assumption. *) *)
  (*   + erewrite ren_inst_vl_tm with (sigma := up_vl_vl sigma); eauto. *)
  (*     (* * cbn. unfold cast_vl_tm. reflexivity. *) *)
  (*     (* * apply up_ren_up. assumption. *) *)
  (*   + apply ren_inst_vl_ty. assumption. *)
  (*   + apply ren_inst_vl_tm. assumption. *)

  (* - induction s; cbn; f_equal; eauto. *)
  (* - induction s; cbn; f_equal; eauto. *)

  (* Beware: using eauto in a fixpoint is dangerous, but we use it *after* f_equal. *)
  all: induction s; cbn; f_equal; eauto using up_ren_up.
Qed.

Instance AsimplSubstUp_ty_vl (sigma_vl tau_vl: index -> vl)
(E_vl: AsimplGen (var_vl 0 .: sigma_vl >>> (subst_vl ((cast_ty_vl (S >>> var_vl))))) tau_vl) : AsimplSubst_ty (up_ty_vl sigma_vl) tau_vl.
Proof.
  hnf.
  unfold up_ty_vl. intros x. rewrite <- E_vl.
  simpl. destruct x.
  - reflexivity.
  - simpl. unfold compren_ty.
    erewrite ren_inst_vl_vl; reflexivity.
Qed.




Instance AsimplCast_tm_vl (sigma_vl: index -> vl)
(tau: subst_of subst_of_vl)
(E: AsimplSubst_vl sigma_vl tau) : AsimplSubst_vl ((cast_tm_vl sigma_vl)) tau.
Proof. apply E. Qed.
Typeclasses Opaque cast_tm_vl.



Instance AsimplAsimplInst_tm (s t: tm)
(sigma sigma': subst_of subst_of_tm)
(E_sigma: AsimplSubst_tm sigma sigma')
(E: AsimplInst_tm s sigma' t) : Asimpl (subst_tm sigma s) t.
Proof. rewrite <- E. apply subst_eq_tm. assumption. Qed.

Instance AsimplInstRefl_tm (s: tm) (sigma: subst_of subst_of_tm) : AsimplInst_tm s sigma (s.[ sigma ]) |100.
Proof. reflexivity. Qed.



Instance asimplInst_tapp (s0 s1 s0' s1': _)
(sigma theta_0 theta_1: subst_of subst_of_tm)
(E_0': AsimplSubst_tm (sigma) theta_0)
(E_1': AsimplSubst_tm (sigma) theta_1)
(E_0: AsimplInst_tm s0 theta_0 s0')
(E_1: AsimplInst_tm s1 theta_1 s1') : AsimplInst_tm (tapp s0 s1) sigma (tapp s0' s1').
Admitted.
Instance asimplInst_tlet (s0 s1 s0' s1': _)
(sigma theta_0 theta_1: subst_of subst_of_tm)
(E_0': AsimplSubst_tm (sigma) theta_0)
(E_1': AsimplSubst_tm ((up_tm_vl sigma)) theta_1)
(E_0: AsimplInst_tm s0 theta_0 s0')
(E_1: AsimplInst_tm s1 theta_1 s1') : AsimplInst_tm (tlet s0 s1) sigma (tlet s0' s1').
Admitted.
Instance asimplInst_tproj (s0 s0': _)
(sigma theta_0: subst_of subst_of_tm)
(E_0': AsimplSubst_tm (sigma) theta_0)
(E_0: AsimplInst_tm s0 theta_0 s0') : AsimplInst_tm (tproj s0) sigma (tproj s0').
Admitted.
Instance asimplInst_vt (s0 s0': _)
(sigma: subst_of subst_of_tm)
(theta_0: subst_of subst_of_vl)
(E_0': AsimplSubst_vl (((cast_tm_vl sigma))) theta_0)
(E_0: AsimplInst_vl s0 theta_0 s0') : AsimplInst_tm (vt s0) sigma (vt s0').
Admitted.

Instance AsimplId_tm (s: tm) : AsimplInst_tm s var_vl s.
Proof. apply id_tm; reflexivity. Qed.

Instance AsimplInstInst_tm (s t: tm)
(sigma sigma' tau sigma_tau: subst_of subst_of_tm)
(E1: AsimplSubst_tm sigma sigma')
(E2: AsimplComp_tm sigma' tau sigma_tau)
(E3: AsimplInst_tm s sigma_tau t) : AsimplInst_tm (subst_tm sigma s) tau t.
Admitted.

Instance AsimplSubstRefl_tm (sigma: subst_of subst_of_tm) : AsimplSubst_tm sigma sigma | 100.
Admitted.

Instance AsimplSubstComp_tm (sigma sigma' tau tau' theta: subst_of subst_of_tm)
(E_sigma: AsimplSubst_tm sigma sigma')
(E_tau: AsimplSubst_tm tau tau')
(E: AsimplComp_tm sigma' tau' theta) : AsimplSubst_tm (comp_tm sigma tau) theta |90.
Admitted.

Instance AsimplSubstCongr_tm (sigma_vl tau_vl: index -> vl) (E_vl: AsimplGen sigma_vl tau_vl) : AsimplSubst_tm sigma_vl tau_vl |95.
Proof. repeat split; assumption. Qed.

Instance AsimplCompRefl_tm (sigma tau: subst_of subst_of_tm) : AsimplComp_tm sigma tau (comp_tm sigma tau) | 100.
Admitted.



Instance AsimplCompIdR_tm (sigma: index -> tm) : AsimplComp sigma (subst_tm var_vl) sigma.
Proof. intros x. apply id_tm; reflexivity. Qed.

Instance AsimplCompAsso_tm (sigma tau theta tau_theta sigma_tau_theta: subst_of subst_of_tm)
(E: AsimplComp_tm tau theta tau_theta)
(E': AsimplComp_tm sigma tau_theta sigma_tau_theta) : AsimplComp_tm (comp_tm sigma tau) theta sigma_tau_theta.
Admitted.

Instance AsimplCompCongr_tm (sigma_vl theta_vl: index -> vl)
(tau_vl: subst_of subst_of_vl)
(tau: subst_of subst_of_tm)
(E_vl: AsimplSubst_vl ((cast_tm_vl tau)) tau_vl)
(E_vl': AsimplComp sigma_vl (subst_vl tau_vl) theta_vl) : AsimplComp_tm sigma_vl tau theta_vl.
Admitted.

Instance AsimplCompCongr'_tm (sigma_vl theta_vl: index -> vl)
(tau_vl: subst_of subst_of_vl)
(tau: subst_of subst_of_tm)
(E_vl: AsimplSubst_vl ((cast_tm_vl tau)) tau_vl)
(E_vl': AsimplComp sigma_vl (subst_vl tau_vl) theta_vl) : AsimplComp (subst_tm sigma_vl) (subst_tm tau) (subst_tm theta_vl).
Admitted.

Instance AsimplRefl_tm (s: tm) : Asimpl s s | 100.
Proof. reflexivity. Qed.

Instance AsimplGenComp_tm (sigma sigma': index -> tm)
(tau tau': subst_of subst_of_tm)
(theta: index -> tm)
(E: AsimplGen sigma sigma')
(E': AsimplSubst_tm tau tau')
(E'': AsimplComp sigma' (subst_tm tau') theta) : AsimplGen (sigma >>> (subst_tm tau) ) theta.
Proof. intros x. rewrite <- E''. simpl. rewrite E. now apply subst_eq_tm . Qed.

Instance AsimplSubstUp_tm_vl (sigma_vl tau_vl: index -> vl)
(E_vl: AsimplGen (var_vl 0 .: sigma_vl >>> (subst_vl ((cast_tm_vl (S >>> var_vl))))) tau_vl) : AsimplSubst_tm (up_tm_vl sigma_vl) tau_vl.
Admitted.





Instance AsimplToVar_vl (sigma_vl: index -> vl) : AsimplGen (toVar_vl sigma_vl) sigma_vl.
Proof. intros x. reflexivity. Qed.

Instance AsimplAsimplInst_vl (s t: vl)
(sigma sigma': subst_of subst_of_vl)
(E_sigma: AsimplSubst_vl sigma sigma')
(E: AsimplInst_vl s sigma' t) : Asimpl (subst_vl sigma s) t.
Proof. rewrite <- E. apply subst_eq_vl. assumption. Qed.

Instance AsimplInstRefl_vl (s: vl) (sigma: subst_of subst_of_vl) : AsimplInst_vl s sigma (s.[ sigma ]) |100.
Proof. reflexivity. Qed.

Instance AsimplInstVar_vl (x y: index)
(sigma: subst_of subst_of_vl)
(sigma': index -> vl)
(s: vl)
(E: AsimplIndex x y)
(E': AsimplGen (toVar_vl sigma) sigma')
(E'': AsimplVarInst y sigma' s) : AsimplInst_vl (var_vl x) sigma s.
Proof. rewrite E. rewrite <- E''. apply E'.  Qed.

Instance asimplInst_vabs (s0 s0': _)
(sigma: subst_of subst_of_vl)
(theta_0: subst_of subst_of_tm)
(E_0': AsimplSubst_tm ((up_vl_vl ((cast_vl_tm sigma)))) theta_0)
(E_0: AsimplInst_tm s0 theta_0 s0') : AsimplInst_vl (vabs s0) sigma (vabs s0').
Admitted.
Instance asimplInst_vrec (s0 s0': _)
(sigma: subst_of subst_of_vl)
(theta_0: subst_of subst_of_tm)
(E_0': AsimplSubst_tm ((up_vl_vl ((cast_vl_tm sigma)))) theta_0)
(E_0: AsimplInst_tm s0 theta_0 s0') : AsimplInst_vl (vrec s0) sigma (vrec s0').
Admitted.
Instance asimplInst_vpack (s0 s1 s0' s1': _)
(sigma: subst_of subst_of_vl)
(theta_0: subst_of subst_of_ty)
(theta_1: subst_of subst_of_tm)
(E_0': AsimplSubst_ty (((cast_vl_ty sigma))) theta_0)
(E_1': AsimplSubst_tm (((cast_vl_tm sigma))) theta_1)
(E_0: AsimplInst_ty s0 theta_0 s0')
(E_1: AsimplInst_tm s1 theta_1 s1') : AsimplInst_vl (vpack s0 s1) sigma (vpack s0' s1').
Admitted.

Instance AsimplId_vl (s: vl) : AsimplInst_vl s var_vl s.
Proof. apply id_vl; reflexivity. Qed.

Instance AsimplInstInst_vl (s t: vl)
(sigma sigma' tau sigma_tau: subst_of subst_of_vl)
(E1: AsimplSubst_vl sigma sigma')
(E2: AsimplComp_vl sigma' tau sigma_tau)
(E3: AsimplInst_vl s sigma_tau t) : AsimplInst_vl (subst_vl sigma s) tau t.
Admitted.

Instance AsimplSubstRefl_vl (sigma: subst_of subst_of_vl) : AsimplSubst_vl sigma sigma | 100.
Admitted.

Instance AsimplSubstComp_vl (sigma sigma' tau tau' theta: subst_of subst_of_vl)
(E_sigma: AsimplSubst_vl sigma sigma')
(E_tau: AsimplSubst_vl tau tau')
(E: AsimplComp_vl sigma' tau' theta) : AsimplSubst_vl (comp_vl sigma tau) theta |90.
Admitted.

Instance AsimplSubstCongr_vl (sigma_vl tau_vl: index -> vl) (E_vl: AsimplGen sigma_vl tau_vl) : AsimplSubst_vl sigma_vl tau_vl |95.
Proof. repeat split; assumption. Qed.

Instance AsimplCompRefl_vl (sigma tau: subst_of subst_of_vl) : AsimplComp_vl sigma tau (comp_vl sigma tau) | 100.
Admitted.

Instance AsimplCompIdL_vl (sigma: subst_of subst_of_vl)
(tau: index -> vl)
(E: AsimplGen (toVar_vl sigma) tau) : AsimplComp var_vl (subst_vl sigma) tau.
Admitted.

Instance AsimplCompIdR_vl (sigma: index -> vl) : AsimplComp sigma (subst_vl var_vl) sigma.
Proof. intros x. apply id_vl; reflexivity. Qed.

Instance AsimplCompAsso_vl (sigma tau theta tau_theta sigma_tau_theta: subst_of subst_of_vl)
(E: AsimplComp_vl tau theta tau_theta)
(E': AsimplComp_vl sigma tau_theta sigma_tau_theta) : AsimplComp_vl (comp_vl sigma tau) theta sigma_tau_theta.
Admitted.

Instance AsimplCompCongr_vl (sigma_vl theta_vl: index -> vl)
(tau_vl tau: subst_of subst_of_vl)
(E_vl: AsimplSubst_vl (tau) tau_vl)
(E_vl': AsimplComp sigma_vl (subst_vl tau_vl) theta_vl) : AsimplComp_vl sigma_vl tau theta_vl.
Admitted.

Instance AsimplCompCongr'_vl (sigma_vl theta_vl: index -> vl)
(tau_vl tau: subst_of subst_of_vl)
(E_vl: AsimplSubst_vl (tau) tau_vl)
(E_vl': AsimplComp sigma_vl (subst_vl tau_vl) theta_vl) : AsimplComp (subst_vl sigma_vl) (subst_vl tau) (subst_vl theta_vl).
Admitted.

Instance AsimplRefl_vl (s: vl) : Asimpl s s | 100.
Proof. reflexivity. Qed.

Instance AsimplGenComp_vl (sigma sigma': index -> vl)
(tau tau': subst_of subst_of_vl)
(theta: index -> vl)
(E: AsimplGen sigma sigma')
(E': AsimplSubst_vl tau tau')
(E'': AsimplComp sigma' (subst_vl tau') theta) : AsimplGen (sigma >>> (subst_vl tau) ) theta.
Proof. intros x. rewrite <- E''. simpl. rewrite E. now apply subst_eq_vl . Qed.

Instance AsimplSubstUp_vl_vl (sigma_vl tau_vl: index -> vl)
(E_vl: AsimplGen (var_vl 0 .: sigma_vl >>> (subst_vl ((S >>> var_vl)))) tau_vl) : AsimplSubst_vl (up_vl_vl sigma_vl) tau_vl.
Admitted.

Typeclasses Opaque toVar_vl.

